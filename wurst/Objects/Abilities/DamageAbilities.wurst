package DamageAbilities

import AbilityObjEditing
import ItemStatsDef
import ObjectIdGenerator
import CommonDescriptions
import codeDamageTypings
import Abilities
import ClosureForGroups
import ActiveAbilityDef

// ----------------------------------------------------------------------------

public function addAbilityDealMagicDamage(real damage, int manaCost, real cd) returns ItemStats
    let effects = wordAbilityMagicDamage.format(damage.toString(), cd.toString())

    return new TargetAbility(effects, manaCost, cd, (unit caster, unit target) -> begin
        caster.damageTargetCode(damage, target, null, -1, damageType.MAGICAL)
    end)
    .register()
    
// ----------------------------------------------------------------------------

public function addAbilityDealMagicDamageInt(real intFactor, int manaCost, real cd) returns ItemStats
    let effects = wordAbilityMagicDamageInt.format(intFactor.toString(), cd.toString())

    return new TargetAbility(effects, manaCost, cd, (unit caster, unit target) -> begin
        let damage = caster.getInt(true) * intFactor
        caster.damageTargetCode(damage, target, null, -1, damageType.MAGICAL)
    end)
    .register()

// ----------------------------------------------------------------------------

public function addAbilityDealMagicDamageInt2(real damage, real intFactor, int manaCost, real cd) returns ItemStats
    let effects = wordAbilityMagicDamageInt2.format(damage.toString(), intFactor.toString(), cd.toString())

    return new TargetAbility(effects, manaCost, cd, (unit caster, unit target) -> begin
        let damageSum = damage + caster.getInt(true) * intFactor
        caster.damageTargetCode(damageSum, target, null, -1, damageType.MAGICAL)
    end)
    .register()

// ----------------------------------------------------------------------------

public function addAbilityDealAoeDamage(real damage, real range, damageType damageType, int manaCost, real cd) returns ItemStats
    let effects = wordAbilityAoeDamage.format(damage.toString(), damageType.toString(), range.toString(0), cd.toString())
    
    return new CastAbility(effects, manaCost, cd, (unit caster) -> begin
        forUnitsInRange(caster.getPos(), range) (unit u) ->
            if(u.isEnemyOf(caster))
                caster.damageTargetCode(damage, u, null, -1, damageType)
    end)
    .register()

// ----------------------------------------------------------------------------

public function addAbilityPhoenixFire(real damage, real attackCd, real range) returns ItemStats
    let effects = wordPhoenixFire.format(attackCd.toString(), damage.toString(), range.toString())

    return passiveAbility(effects) (int abilityId) ->
        return new AbilityDefinitionPhoenixFire(abilityId)
        ..setDamagePerSecond(1, 0)
        ..setInitialDamage(1, damage)
        ..setDurationHero(1, 0.1)
        ..setDurationNormal(1, 0.1)
        ..setCooldown(1, attackCd)
        ..setCastRange(1, range)
        ..setMissileArt(Abilities.avengerMissile)

// ----------------------------------------------------------------------------

public function addAbilityHolyLight(real healIntFactor, real healAmount, real damageFactor, int manaCost, real cd) returns ItemStats
    let effects = wordAbilityHolyLight.format(healAmount.toString(), healIntFactor.toString(), (100*damageFactor).toString(), cd.toString())

    return new TargetAbility(effects, manaCost, cd, (unit caster, unit target) -> begin
        let heal = healIntFactor * caster.getInt(true) + healAmount

        if (target.isEnemyOf(caster))
            let damage = heal * damageFactor
            caster.damageTargetCode(damage, target, null, -1, damageType.MAGICAL)
            
            flashEffect(Abilities.holyBoltSpecialArt, target.getPos())
        else
            let newHp = (target.getMaxHP() + heal)
            let maxHp = target.getMaxHP()
            target.setHP(newHp > maxHp ? maxHp : newHp)

            flashEffect(Abilities.healTarget, target.getPos())
    end)
    .register()

// ----------------------------------------------------------------------------

public function addAbilityLightingBoltStun(real damage, real intFactor, real stunDuration, int manaCost, real cd) returns ItemStats
    let effects = wordAbilityMagicDamageInt2.format(damage.toString(), intFactor.toString(), cd.toString())
    
    return new TargetAbility(effects, manaCost, cd, (unit caster, unit target) -> begin
        let damageSum = caster.getInt(true) * intFactor + damage
        caster.damageTargetCode(damageSum, target, null, -1, damageType.MAGICAL)
    end)
    ..setDurationNormal(1, stunDuration)
    ..setDurationHero(1, stunDuration)
    .register()

// ----------------------------------------------------------------------------



// ----------------------------------------------------------------------------