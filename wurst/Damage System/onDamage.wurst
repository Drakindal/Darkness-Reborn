package OnDamage

import MyUnitIds
// import DamageDetection
import DamageEvent
import MyAbilityIds
import EntityStats
import MyBuffIds
import WaveHeroSetup
import DragonTurtle
import Turtle
import ThornsAuraWave
import Global_Variables
import AbilitiesList
import Pitlord_R
import Pitlord_E
import DamageTypes
import UnitStats

@configurable constant DETECT_NATIVE_ABILITIES = true

let difficultyDamageIncrease = [0.5, 0.75, 1., 1.5, 2.]

texttag justaposeCrit

function getReducedDamage() returns real

    return DamageEvent.getUnreducedOriginalAmount() - DamageEvent.getAmount()

init
    DamageEvent.addListener(0) -> 
        let src  = DamageEvent.getSource()
        let targ = DamageEvent.getTarget()
        src.wasAttacked()

        // Change damage dealt by enemies to players due to game difficulty

        // WIP. We increase only DamageAmount, but also should change DamageUnreducedAmount.
        // But there are no function to change it.
        if(src.isEnemyOf(PLAYER_ALLY_BASE))
            DamageEvent.setAmount(DamageEvent.getAmount() * difficultyDamageIncrease[gameMode])
        
        switch DamageEvent.getType()
            case ATTACK
                let dt = src.isRanged() ? damageType.PhysicalRanged : damageType.PhysicalMelee

                DamageEvent.setAmount(targ.getStats().calcDamage(dt, DamageEvent.getAmount(), DamageEvent.getUnreducedAmount()))
                
                if not src.isRanged()
                    reflectionChecks(src, targ)

                physicalDamageChecks(src, targ)

                // Warden T ability.
                if src.hasAbility('B003')
                    src.removeAbility('B003')

            case SPELL
                DamageEvent.setAmount(targ.getStats().calcDamage(damageType.Magical, DamageEvent.getAmount(), DamageEvent.getUnreducedAmount()))

                magicDamageChecks(src, targ)
                
            case CODE
                let dt = (DamageEvent.getDamageType() == DAMAGE_TYPE_NORMAL) ? damageType.PhysicalRanged : damageType.Magical
                
                DamageEvent.setAmount(targ.getStats().calcDamage(dt, DamageEvent.getAmount(), DamageEvent.getUnreducedAmount()))

                if(DamageEvent.getDamageType() == DAMAGE_TYPE_NORMAL)
                    if not src.isRanged()
                        reflectionChecks(src, targ)
                    physicalDamageChecks(src, targ)
                else if (DamageEvent.getDamageType() == DAMAGE_TYPE_MAGIC)
                    magicDamageChecks(src, targ)
            default

    DamageEvent.addListener(1) ->
        let src = DamageEvent.getSource()
        let targ = DamageEvent.getTarget()
        if (DamageEvent.getType() == ATTACK)
            let damtyp = DamageEvent.getDamageType()
            if (damtyp == DAMAGE_TYPE_NORMAL or damtyp == DAMAGE_TYPE_MAGIC)
                
                for abilityInfo in abilitiesListOnDamageTaken
                    if (targ.hasItemById(abilityInfo.itemId))
                        abilityInfo.runHandler(src, targ)
                
    DamageEvent.addListener(2) ->
        let src = DamageEvent.getSource()
        let targ = DamageEvent.getTarget()
        if (DamageEvent.getType() == ATTACK)
            if src.isIllusion()
                skip
            else
                let damtyp = DamageEvent.getDamageType()
                if (damtyp == DAMAGE_TYPE_NORMAL or damtyp == DAMAGE_TYPE_MAGIC)
                    
                    for abilityInfo in abilitiesListOnDamageDealt
                        if (src.hasItemById(abilityInfo.itemId))
                            abilityInfo.runHandler(src, targ)

function magicDamageChecks(unit src, unit targ)
    if(targ.getAbilityLevel(UTHER_ABILITY_3) > 0)
        DamageEvent.setAmount(DamageEvent.getAmount() * (1-0.02*targ.getAbilityLevel(UTHER_ABILITY_3)))

function physicalDamageChecks(unit src, unit targ)
    // Uther Damage reduction
    if(targ.getAbilityLevel(UTHER_ABILITY_3) > 0)
        DamageEvent.setAmount(DamageEvent.getAmount() * (1-0.02*targ.getAbilityLevel(UTHER_ABILITY_3)))
    // Wolfman attack
    if src.hasAbility(WOLF_BUFF_1)
        src.addHP(DamageEvent.getAmount() * 0.25)

function reflectionChecks(unit src, unit targ)
    let dam = DamageEvent.getAmount()
    let targuID = targ.getTypeId()

    for abilityInfo in abilitiesListReflections
        if (targ.hasItemById(abilityInfo.itemId))
            abilityInfo.runHandler(src, targ)

    if(targuID == WAVE_MOB_18)
        turtle(targ, src, dam)
    if(targuID == WAVE_BOSS_95)
        dragonTurtle(targ, src, dam)
    if(targ.getAbilityLevel('A0RI') > 0)
        pitLordThorn(targ, src)
    if(targ.getAbilityLevel('a0RL') > 0)
        pitLordDemonSkin(targ, src, dam)
    if(targ.hasAbility('BEah'))
        thornsAuraWave(targ, src, dam)