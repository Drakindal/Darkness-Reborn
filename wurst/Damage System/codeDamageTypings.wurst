package codeDamageTypings
import HashMap
import DamageEvent
import Global_Variables
import ClosureEvents
import LinkedList

public let unitStatMap = new HashMap<integer, UnitStats>
let physPenItemHash = compiletime(new HashMap<int, real>)
let magicResItemHash = compiletime(new HashMap<int, real>)

public enum damageType
    PURE
    PHYSICALMELEE
    PHYSICALRANGED
    MAGICAL

public enum penetrationType
    UNIVERSAL
    MAGICAL
    PHYSICAL

public enum resistanceType
    UNIVERSAL
    PHYSICAL
    MAGICAL

public class UnitStats
    // Base pen, this penetration comes from hero skills temporary or permanent
    private real basePhysPen = 0
    private real baseMagicPen = 0
    private real baseUniversalPen = 0
    // Additive pen, this comes from items or other buff sources
    private real additivePhysPen = 0
    private real additiveMagicPen = 0
    private real additiveUniversalPen = 0
    // Resistances, comes from items or hero sources
    private real magicRes = 0
    private real physRes = 0
    private real universalRes = 0

    function addAdditivePen(penetrationType penType, real amount)
        switch penType
            case penetrationType.MAGICAL
                additiveMagicPen += amount
            case penetrationType.PHYSICAL
                additivePhysPen += amount
            case penetrationType.UNIVERSAL
                additiveUniversalPen += amount

    function subAdditivePen(penetrationType penType, real amount)
        switch penType
            case penetrationType.MAGICAL
                additiveMagicPen -= amount
            case penetrationType.PHYSICAL
                additivePhysPen -= amount
            case penetrationType.UNIVERSAL
                additiveUniversalPen -= amount

    function setAdditivePen(penetrationType penType, real amount)
        switch penType
            case penetrationType.MAGICAL
                additiveMagicPen = amount
            case penetrationType.PHYSICAL
                additivePhysPen = amount
            case penetrationType.UNIVERSAL
                additiveUniversalPen = amount

    function getAdditivePen(penetrationType penType) returns real
        switch penType
            case penetrationType.MAGICAL
                return additiveMagicPen
            case penetrationType.PHYSICAL
                return additivePhysPen
            case penetrationType.UNIVERSAL
                return additiveUniversalPen

    function addBasePen(penetrationType penType, real amount)
        switch penType
            case penetrationType.MAGICAL
                baseMagicPen += amount
            case penetrationType.PHYSICAL
                basePhysPen += amount
            case penetrationType.UNIVERSAL
                baseUniversalPen += amount

    function subBasePen(penetrationType penType, real amount)
        switch penType
            case penetrationType.MAGICAL
                baseMagicPen -= amount
            case penetrationType.PHYSICAL
                basePhysPen -= amount
            case penetrationType.UNIVERSAL
                baseUniversalPen -= amount

    function setBasePen(penetrationType penType, real amount)
        switch penType
            case penetrationType.MAGICAL
                baseMagicPen = amount
            case penetrationType.PHYSICAL
                basePhysPen = amount
            case penetrationType.UNIVERSAL
                baseUniversalPen = amount

    function getBasePen(penetrationType penType) returns real
        switch penType
            case penetrationType.MAGICAL
                return baseMagicPen
            case penetrationType.PHYSICAL
                return basePhysPen
            case penetrationType.UNIVERSAL
                return baseUniversalPen

    function getCombinedPen(penetrationType penType) returns real
        switch penType
            case penetrationType.MAGICAL
                return baseMagicPen + additiveMagicPen
            case penetrationType.PHYSICAL
                return basePhysPen + additivePhysPen
            case penetrationType.UNIVERSAL
                return baseUniversalPen + additiveUniversalPen

    function addResistance(resistanceType resType, real amount)
        switch resType
            case resistanceType.MAGICAL
                magicRes += amount
            case resistanceType.PHYSICAL
                physRes += amount
            case resistanceType.UNIVERSAL
                universalRes += amount

    function subResistance(resistanceType resType, real amount)
        switch resType
            case resistanceType.MAGICAL
                magicRes -= amount
            case resistanceType.PHYSICAL
                physRes -= amount
            case resistanceType.UNIVERSAL
                universalRes -= amount

    function setResistance(resistanceType resType, real amount)
        switch resType
            case resistanceType.MAGICAL
                magicRes = amount
            case resistanceType.PHYSICAL
                physRes = amount
            case resistanceType.UNIVERSAL
                universalRes = amount
    
    function getResistance(resistanceType resType) returns real
        switch resType
            case resistanceType.MAGICAL
                return magicRes
            case resistanceType.PHYSICAL
                return physRes
            case resistanceType.UNIVERSAL
                return universalRes

    private static function enumerateResistances(unit toEnumerate, resistanceType resType)
        let itemInUnit = new LinkedList<item>()
        for int i = 0 to 5
            itemInUnit.add(toEnumerate.itemInSlot(i))
        itemInUnit.forEach() (item t) ->
            if(t == null)
                itemInUnit.remove(t)
        var resistances = 0.
        switch resType
            case resistanceType.MAGICAL
                itemInUnit.forEach() (item t) ->
                    resistances += magicResItemHash.get(t.getTypeId())
                    unitStatMap.get(toEnumerate.getTypeId()).setResistance(resType, resistances)
            case resistanceType.PHYSICAL
                itemInUnit.forEach() (item t) ->
                    resistances += magicResItemHash.get(t.getTypeId())
                    unitStatMap.get(toEnumerate.getTypeId()).setResistance(resType, resistances)
            case resistanceType.UNIVERSAL
                itemInUnit.forEach() (item t) ->
                    resistances += magicResItemHash.get(t.getTypeId())
                    unitStatMap.get(toEnumerate.getTypeId()).setResistance(resType, resistances)
        destroy itemInUnit

    static function enumerateAllResistances(unit toEnumerate)
        if(unitStatMap.has(toEnumerate.getTypeId()))
            enumerateResistances(toEnumerate, resistanceType.MAGICAL)
            enumerateResistances(toEnumerate, resistanceType.PHYSICAL)
            enumerateResistances(toEnumerate, resistanceType.UNIVERSAL)
        else
            let newStats = new UnitStats()
            unitStatMap.put(toEnumerate.getTypeId(), newStats)
            enumerateResistances(toEnumerate, resistanceType.MAGICAL)
            enumerateResistances(toEnumerate, resistanceType.PHYSICAL)
            enumerateResistances(toEnumerate, resistanceType.UNIVERSAL)

    private static function enumeratePens(unit toEnumerate, penetrationType penType)
        let itemInUnit = new LinkedList<item>()
        for int i = 0 to 5
            itemInUnit.add(toEnumerate.itemInSlot(i))
        itemInUnit.forEach() (item t) ->
            if(t == null)
                itemInUnit.remove(t)        
        var resistances = 0.
        switch penType
            case penetrationType.MAGICAL
                itemInUnit.forEach() (item t) ->
                    resistances += magicResItemHash.get(t.getTypeId())
                    unitStatMap.get(toEnumerate.getTypeId()).setAdditivePen(penType, resistances)
            case penetrationType.PHYSICAL
                itemInUnit.forEach() (item t) ->
                    resistances += magicResItemHash.get(t.getTypeId())
                    unitStatMap.get(toEnumerate.getTypeId()).setAdditivePen(penType, resistances)
            case penetrationType.UNIVERSAL
                itemInUnit.forEach() (item t) ->
                    resistances += magicResItemHash.get(t.getTypeId())
                    unitStatMap.get(toEnumerate.getTypeId()).setAdditivePen(penType, resistances)
        destroy itemInUnit

    static function enumerateAllPens(unit toEnumerate)
        enumeratePens(toEnumerate, penetrationType.MAGICAL)
        enumeratePens(toEnumerate, penetrationType.PHYSICAL)
        enumeratePens(toEnumerate, penetrationType.UNIVERSAL)

init
    statscheck()

function unit.getItemBySlot(int slot) returns item
    return UnitItemInSlot(this, slot)

public function damageType.toString() returns string
    switch this
        case damageType.MAGICAL
            return "magic damage"
        case damageType.PHYSICALMELEE
            return "physical melee damage"
        case damageType.PHYSICALRANGED
            return "physical range damage"
        case damageType.PURE
            return "pure damage"
        default
            return "null"

public function integer.getPen(penetrationType typeToGet) returns real
    let stateMap = unitStatMap.get(this)
    if stateMap == null
        return 0
    return stateMap.getCombinedPen(typeToGet)

public function unit.getPen(penetrationType typeToGet) returns real
    return this.getTypeId().getPen(typeToGet)

public function integer.getRes(resistanceType typeToGet) returns real
    let stateMap = unitStatMap.get(this)
    if stateMap == null
        return 0
    return stateMap.getResistance(typeToGet)

public function unit.getRes(resistanceType typeToGet) returns real
    return this.getTypeId().getRes(typeToGet)

public function int.putInPhysPenItemHash(real input)
    physPenItemHash.put(this, input * 0.01)

public function int.putInMagicResItemHash(real input)
    magicResItemHash.put(this, input * 0.01)

public function int.getPhysPenItemHash() returns real
    return physPenItemHash.get(this)

public function int.getMagicResItemHash() returns real
    return magicResItemHash.get(this)

public function item.getPhysPenItemHash() returns real
    return physPenItemHash.get(this.getTypeId())

public function item.getMagicResItemHash() returns real
    return magicResItemHash.get(this.getTypeId())

function enumerateMagicRes(integer unitID, real magicRes)
    if unitStatMap.get(unitID) != null
        unitStatMap.get(unitID).setResistance(resistanceType.MAGICAL, magicRes * 0.01)
    else
        let newStats = new UnitStats()
        newStats.setResistance(resistanceType.MAGICAL, magicRes * 0.01)
        unitStatMap.put(unitID, newStats)
        
public function integer.enumerateMagicResistance(real magicResistance)
    enumerateMagicRes(this, magicResistance)

public function unit.enumerateMagicResistance(real magicResistance)
    enumerateMagicRes(this.getTypeId(), magicResistance)

function enumeratePhysPen(integer unitID, real physPen)
    if unitStatMap.has(unitID)
        unitStatMap.get(unitID).setBasePen(penetrationType.PHYSICAL, physPen * 0.01)
    else
        let newStats = new UnitStats()
        newStats.setBasePen(penetrationType.PHYSICAL, physPen * 0.01)
        unitStatMap.put(unitID, newStats)

public function integer.enumeratePhysicalPenetration(real physicalPenetration)
    enumeratePhysPen(this, physicalPenetration)

public function unit.enumeratePhysicalPenetration(real physicalPenetration)
    enumeratePhysPen(this.getTypeId(), physicalPenetration)

// DAMAGE

public function unit.damageTargetCode(real amount, unit target, DamageElement element, integer id, damageType damType) returns bool
    DamageEvent.setNextDamageElement(element)
    DamageEvent.setNextDamageFromCode()
    if(id > -1)
        DamageEvent.setNextDamageId(id)

    switch damType
        case damageType.PURE
            this.damageTarget(target, amount, false, false, ATTACK_TYPE_MELEE, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS)
        case damageType.PHYSICALMELEE
            this.damageTarget(target, amount, false, false, ATTACK_TYPE_MELEE, DAMAGE_TYPE_NORMAL, WEAPON_TYPE_CLAW_MEDIUM_SLICE)
        case damageType.PHYSICALRANGED
            this.damageTarget(target, amount, false, false, ATTACK_TYPE_MELEE, DAMAGE_TYPE_NORMAL, WEAPON_TYPE_WHOKNOWS)
        case damageType.MAGICAL
            this.damageTarget(target, amount, false, false, ATTACK_TYPE_MELEE, DAMAGE_TYPE_MAGIC, WEAPON_TYPE_WHOKNOWS)
    return true
        

function statscheck()
    EventListener.add(EVENT_PLAYER_CHAT_FILTER) ->
        if EventData.getChatMessage().substring(0, 6).toLowerCase() == "-stats"
            let p = GetTriggerPlayer()
            let u = playerHero.get(p)
            printTimedToPlayer("Physical Penetration: "+ (u.getPen(penetrationType.PHYSICAL) * 100).toString() + "%" +
            "\nMagic Ressistence: "+ (u.getRes(resistanceType.MAGICAL) * 100).toString() +"%", 10, p)

public function unit.isRanged() returns boolean
    return this.getFieldWeapon(UNIT_WEAPON_RF_ATTACK_RANGE, 0) > 230